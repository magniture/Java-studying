## 1.什么是supermin
Supermin是用于构建Supermin设备的工具。这些是小型设备（类似于虚拟机），通常大小约为100KB，当您需要启动其中一个设备时，它们会在短短几秒钟内完全实例化。
### 1.1 基本操作
supermin工具可以在两种模式下使用，准备一个小型的supermin设备，这是在构建系统上完成的。以及building，它使用supermin设备并构建一个完整的可引导设备，这是在最终用户的系统上完成的。
Supermin不需要以root身份运行，通常不应以root身份进行运行。它不会影响主机系统或主机系统上安装的软件包。
### 1.2 准备模式
--prepare在给定的输出目录中创建了一个小的supermin设备。你给它一个你想要安装的软件包的列表，supermin会自动找到依赖项。必须在主机上安装软件包列表。
```shell
supermin --prepare bash coreutils -o supermin.d
```
### 1.3 构建模式
--build（以前是一个名为“supermin helper”的单独程序）从supermin设备构建整个设备:
```shell
supermin --build --format ext2 supermin.d -o appliance.d
```
### 1.4 构建和缓存
通常，您希望仅根据需要在最终用户计算机上重建设备。Supermin有一些额外的选项来简化此操作：
```shell
supermin --build \
--if-newer --lock /run/user/`id -u`/supermin.lock \
--format ext2 supermin.d -o appliance.d
````

## 2.使用supermin5来构建一个基础镜像
在这个案例中，我将使用 supermin5 命令构建 centos7系统的 docker 镜像，镜像名称为 centos-7，镜像预装 yum、net-tools、initscripts 和 vi 命令
```shell

# 安装supermin
yum -y install supermin*

# supermin5 添加预装工具 yum net-tools initscripts vi
supermin5 -v --prepare bash coreutils  yum  net-tools initscripts vim-minial  -o supermin.d
# supermin5 构建
supermin5 -v --build --format chroot supermin.d -o appliance.d

echo 7 >  appliance.d/etc/yum/vars/releasever
# 镜像打包
tar --numeric-owner -cpf centos-7.tar -C appliance.d .

# 导入镜像
cat centos-7.tar | docker import - centos-7
# 运行
docker run -dit --name centos7 centos-7 /bin/bash
cat /etc/redhat-release

```


在容器中管理数据主要有两种方式：

- 数据卷（Data volumes）
- 数据卷容器（Data volume containers）
#  1.数据卷
##  1.1 什么是数据卷？
  数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：

* 数据卷可以在容器之间共享和重用
* 对数据卷的修改会立马生效
* 对数据卷的更新，不会影响镜像
* 卷会一直存在，直到没有容器使用

数据卷的使用，类似于 Linux 下对目录或文件进行 mount。
## 1.2 创建数据卷
```shell
# 创建一个名为 new-volume 的数据卷
docker volume create new-volume
# 列出
docker volume ls

# 查看卷信息
docker volume inspect new-volume
```
![img_4.png](img_4.png)
## 1.3 挂载数据卷
```shell
# 启动一个挂载新卷的nginx容器
docker run -dit --name nginx -v new-volume:/mnt nginx

# 查看容器的详细信息 grep -a 这里显示具体前后行数
 docker inspect nginx|grep Mounts -a5
```
## 1.4 删除数据卷
数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在 容器被删除后自动删除 数据卷 ，并且也不存在垃圾回收这样的机制来处理没有任 何容器引用的 数据卷 。如果需要在删除容器的同时移除数据卷。可以在删除容器 的时候使用 `docker rm -v `这个命令。

```shell
docker volume rm new-volume
```
无主的数据卷可能会占据很多空间，要清理请使用以下命令

```shell
docker volume prune
```

# 2.数据卷容器
## 2.1 什么是数据卷容器？
数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。
## 2.1、容器间共享卷
在这个案例中，将使用三个nginx容器进行演示，分别为 nginxweb1、nginxweb2、nginxweb3
```shell


# 启动nginxweb1 创建共享卷
docker run -dit --name nginxweb1 -p 8081:80 -v /usr/share/nginx/html nginx
# 启动nginxweb2、nginxweb3 并指定共享卷为 nginxweb1
docker run -dit --name nginxweb2 --volumes-from nginxweb1 -p 8082:80 nginx
docker run -dit --name nginxweb3 --volumes-from nginxweb1 -p 8083:80 nginx
# curl测试
curl localhost:8081
curl localhost:8082
curl localhost:8083
# 进入nginxweb1 进行修改index.html文件，并测试
docker exec -it nginxweb1 bash
容器内操作
echo "This is nginxweb1 website" > /usr/share/nginx/html/index.html
# 退出容器测试 exit
curl localhost:8081
curl localhost:8082
curl localhost:8083

```
# 创建测试网页
```shell
# 创建web1文件夹 以及页面
mkdir /root/web1
echo "This is website 1 Page 11111111111111111" > /root/web1/index.html

# 创建web2文件夹 以及页面
mkdir /root/web2
echo "This is website 2 Page 22222222222222222" > /root/web2/index.html

```
## 创建测试容器 nginx1 nginx2.
```shell
# 创建nginx1容器挂载 web1页面
docker run -dit --name nginx1 -v /root/web1/index.html:/usr/share/nginx/html/index.html -p 8091:80 nginx
# 创建nginx2容器挂载 web2页面
docker run -dit --name nginx2 -v /root/web2/index.html:/usr/share/nginx/html/index.html -p 8092:80 nginx
```
## 1.3 创建nginx.conf配置文件
配置文件中的 172.31.36.113 为宿主机的内网IP地址，请按实际情况修改
配置文件中的两个server ip:port 分别代表当前正在运行的docker容器，待会会将流量分发到tomcat_alb组中，组中的2个server分别处理流量
```shell
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;




events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;


    include /etc/nginx/conf.d/*.conf;
# 定义Tomcat服务的负载均衡
upstream tomcat_alb {

    server 172.31.36.113:8091;

    server 172.31.36.113:8092;

}
server {
    listen       80;
    server_name  172.31.36.113;#宿主机的内网IP

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;
# 这个是调用Tomcat服务的负载均衡
    location / {
        proxy_pass http://tomcat_alb;
    }
}
}
```
## 1.4 创建nginx负载均衡容器
```shell
# -v 标记挂载本地的 /root/nginx.conf 文件
docker run -dit --name nginx-alb -v /root/nginx.conf:/etc/nginx/nginx.conf -p 80:80 nginx
```
## 1.5 负载测试
```shell
# 循环测试
for i in `seq 1 6`;do curl 172.31.36.113;done
```
## 1.6 制作nginx负载均衡dockerfile
通过上面5个步骤的实验，可以很方面的得到实验结果，那么也可以采取打包容器的方式来制作一个nginx的负载均衡容器镜像
### 1.6.1 准备nginx配置文件
首先将1.3的nginx配置文件复制下来，命名为 nginx.conf
```shell

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;




events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;


    include /etc/nginx/conf.d/*.conf;
# 定义Tomcat服务的负载均衡
upstream tomcat_alb {

    server 172.31.36.113:8091;

    server 172.31.36.113:8092;

}
server {
    listen       80;
    server_name  172.31.36.113;#宿主机的内网IP

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;
# 这个是调用Tomcat服务的负载均衡
    location / {
        proxy_pass http://tomcat_alb;
    }
}
}
```
## 1.6.2 启动容器
```shell
docker run -dit --name nginx-alb -v /root/nginx.conf:/etc/nginx/nginx.conf -p 80:80 nginx
```
## 1.6.3 导出容器
```shell
[root@base ~]# docker run -dit --name nginx-alb -v /root/nginx.conf:/etc/nginx/nginx.conf -p 80:80 nginx
6d1e6eff0388267cef089c7db7a6822b9c6ab8ceb4baab4d1338dc6bd3388e08
[root@base ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS                    NAMES
6d1e6eff0388        nginx               "/docker-entrypoin..."   4 seconds ago       Exited (1) 2 seconds ago                            nginx-alb
7dda8b117154        registry            "/entrypoint.sh /e..."   4 hours ago         Up 2 hours                 0.0.0.0:5000->5000/tcp   registry
53b462f31348        ssh-server          "/usr/sbin/sshd -D"      24 hours ago        Exited (0) 22 hours ago                             sshd
88958f0f4fc8        7e989e1e46e7        "/bin/bash"              2 weeks ago         Exited (137) 2 weeks ago                            centos7
[root@base ~]# docker export 6d1e6eff0388 > nginx_alb,tar
[root@base ~]# ls -l|grep nginx_alb
-rw-r--r--.  1 root root 144022528 Aug 25 21:44 nginx_alb,tar

```
# 1.拉取镜像
本次使用的是极狐GitLab Docker 镜像，是极狐GitLab 的整体镜像，在单个容器中运行所有必要的服务
```shell
[root@base ~]# docker pull registry.gitlab.cn/omnibus/gitlab-jh:latest
Trying to pull repository registry.gitlab.cn/omnibus/gitlab-jh ...
latest: Pulling from registry.gitlab.cn/omnibus/gitlab-jh
3b65ec22a9e9: Pull complete
9ce3f6b2507d: Pull complete
ac19a78281d5: Pull complete
bb3c3f1c8644: Pull complete
68ca2a4567a0: Pull complete
bc72d87c5eba: Pull complete
39c50a8c026b: Pull complete
8a5f2ec13e24: Pull complete
Digest: sha256:f21efbd86aadfe2e353799d56811a09a507c7fcf40cd2999fb16237b72469128
Status: Downloaded newer image for registry.gitlab.cn/omnibus/gitlab-jh:latest
[root@base ~]# docker images
REPOSITORY                             TAG                 IMAGE ID            CREATED             SIZE
mysql                                  latest              d39235e17905        5 days ago          571 MB
<none>                                 <none>              75279e2d58b5        5 days ago          101 MB
nginx_alb                              latest              4e28f6e4fc6a        6 days ago          390 MB
ssh-server                             latest              4e28f6e4fc6a        6 days ago          390 MB
registry.gitlab.cn/omnibus/gitlab-jh   latest              e1136770c69f        7 days ago          2.91 GB
docker.io/registry                     latest              3a0f7b0a13ef        3 weeks ago         24.1 MB
docker.io/ubuntu                       <none>              df5de72bdb3b        4 weeks ago         77.8 MB
docker.io/nginx                        latest              605c77e624dd        8 months ago        141 MB
docker.io/ubuntu                       latest              ba6acccedd29        10 months ago       72.8 MB
docker.io/centos                       7                   eeb6ee3f44bd        11 months ago       204 MB

```
# 2.设置卷位置
其实就是设置待会gitlab容器需要挂载卷的位置，当然这些需要提前在宿主机创建

## 2.1 在宿主机创建卷
```shell
[root@base ~]# mkdir /opt/gitlab
[root@base ~]# ls -l /opt/
total 0
drwxr-xr-x. 2 root root 6 Aug 31 18:31 gitlab
[root@base ~]# chmod a+w /opt/gitlab/
[root@base ~]# ls -l /opt/
total 0
drwxrwxrwx. 2 root root 6 Aug 31 18:31 gitlab
```
## 2.2 声明环境变量
```shell
[root@base ~]# export GITLAB_HOME=/opt/gitlab
# 查看
[root@base ~]# export |grep GITLAB_HOME
declare -x GITLAB_HOME="/opt/gitlab"

```
# 3.运行gitlab容器
原本官方使用的是 22:22端口映射，但是因为宿主机已经在使用22的端口，那么就修改一下映射为10022
```shell
[root@base ~]# sudo docker run --detach \
>   --publish 443:443 --publish 80:80 --publish 10022:22 \
>   --name gitlab \
>   --restart always \
>   --volume $GITLAB_HOME/config:/etc/gitlab \
>   --volume $GITLAB_HOME/logs:/var/log/gitlab \
>   --volume $GITLAB_HOME/data:/var/opt/gitlab \
>   --shm-size 256m \
>   registry.gitlab.cn/omnibus/gitlab-jh:latest
b848d1c24944b551525007c4f2749e08ae327b6d8ad9934776c0c038348a517f
[root@base ~]# docker ps -a
CONTAINER ID        IMAGE                                         COMMAND                  CREATED             STATUS                            PORTS                                                             NAMES
b848d1c24944        registry.gitlab.cn/omnibus/gitlab-jh:latest   "/assets/wrapper"        9 seconds ago       Up 5 seconds (health: starting)   0.0.0.0:80->80/tcp, 0.0.0.0:443->443/tcp, 0.0.0.0:10022->22/tcp   gitlab
7dda8b117154        registry                                      "/entrypoint.sh /e..."   6 days ago          Up 3 hours                        0.0.0.0:5000->5000/tcp                                            registry
```
# 4.配置gitlab
进入容器再操作
```shell
[root@base ~]# docker exec -it gitlab bash
root@0fd6622feef2:/#
```
## 4.1 修改gitlab.rb文件(容器 /etc/gitlab/ 目录)
```shell
root@0fd6622feef2:/# vi /etc/gitlab/gitlab.rb
# 修改external_url 'GENERATED_EXTERNAL_URL'
external_url 'http://192.168.200.201'

# 设置ssh链接，使用宿主机的外部端口
gitlab_rails['gitlab_ssh_host'] = '192.168.200.201'
gitlab_rails['gitlab_shell_ssh_port'] = 10022

按下ESC
:wq #保存退出
```
## 4.2 修改gitlab.yaml文件(容器 /opt/gitlab/embedded/service/gitlab-rails/config/ 目录)
```shell
root@0fd6622feef2:/# vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml
# 13行 host修改为 宿主机IP地址
host: 192.168.200.201
ssh_host: 192.168.200.201
按下ESC
:wq #保存退出
```
## 4.3 重启gitlab(容器内操作)
```shell
# 如果timeout(超时)，那么多重启几次
root@0fd6622feef2:/# gitlab-ctl restart
ok: run: alertmanager: (pid 2390) 1s
ok: run: gitaly: (pid 2398) 0s
ok: run: gitlab-exporter: (pid 2412) 0s
ok: run: gitlab-kas: (pid 2414) 0s
ok: run: gitlab-workhorse: (pid 2422) 0s
ok: run: logrotate: (pid 2433) 0s
ok: run: nginx: (pid 2439) 1s
ok: run: postgres-exporter: (pid 2445) 0s
ok: run: postgresql: (pid 2453) 1s
ok: run: prometheus: (pid 2462) 0s
ok: run: puma: (pid 2472) 1s
ok: run: redis: (pid 2477) 0s
ok: run: redis-exporter: (pid 2483) 0s
ok: run: sidekiq: (pid 2571) 0s
ok: run: sshd: (pid 2577) 1s

```
